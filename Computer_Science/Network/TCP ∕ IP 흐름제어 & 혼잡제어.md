---
tags:
  - CS
  - Network
---

**TCP(Transmission Control Protocol)**는 네트워크 통신의 근간을 이루는 중요한 프로토콜이다. TCP는 단순히 데이터를 보내고 받는 것 이상의 기능을 제공하는데, 주된 세 가지 기능은 **흐름 제어**, **오류 제어**, 그리고 **혼잡 제어**가 있다.

이 기능들 덕분에 네트워크에서 발생할 수 있는 문제를 TCP가 알아서 처리해주기 때문에 상위 레이어, 즉 애플리케이션 개발자는 복잡한 네트워크 상황을 신경 쓸 필요가 없다.\
# 1. 흐름 제어 (Flow Control)
흐름 제어는 송신 측과 수신 측의 데이터 처리 속도를 맞추기 위한 장치이다. 송신 측이 데이터를 너무 빨리 보내면 수신 측의 버퍼가 꽉 차서 데이터를 제대로 처리하지 못할 수 있다. 이때 발생하는 문제가 오버플로우(Overflow)다. 이를 막기 위해 TCP는 ==윈도우 크기(Window Size)==를 통해 송신 측이 보낼 수 있는 데이터 양을 조절한다.

윈도우 크기는 수신 측이 자신의 버퍼에서 처리할 수 있는 데이터의 양을 송신 측에 전달하는 정보다. 그래서 송신 측은 이 정보를 바탕으로 한 번에 얼마나 데이터를 보낼지 결정한다.
## 1.1 Stop and wait 방식
가장 기본적인 오류 제어 방식이다. 송신 측은 데이터를 하나 보낸 뒤, ACK를 기다린다. 만약 일정 시간 안에 ACK가 오지 않으면, 송신 측은 해당 데이터를 다시 보낸다.
![[IMG-20241113180245678.png]]
- 이 방식은 매우 간단한 만큼 비효율적이다. 송신 측이 자신의 데이터를 직접 보내봐야 이 데이터를 수신 측이 처리할 수 있는지 알 수 있기 때문이다.
- Stop and Wait 방식을 사용해 흐름 제어를 할 경우에는, 이런 비효율성을 커버하기 위해 이런 단순한 구현이 아닌 여러 가지 오류 제어 방식을 함께 도입해 사용한다.
## 1.2 Sliding Window 방식
그렇기에 더 효율적인 방식인 Sliding Window가 등장한다. Sliding Window는 수신 측이 자신이 한 번에 받을 수 있는 데이터 양(윈도우 크기)을 송신 측에 알려주고, 송신 측은 그 범위 안에서 여러 개의 데이터를 한 번에 보낼 수 있다.
![[IMG-20241113180658395.png]]
e.g. 수신 측이 한 번에 5개의 패킷을 처리할 수 있다면 송신 측은 응답을 기다리지 않고 5개의 패킷을 연달아 보낸다.
### 1.2.1 윈도우 크기 설정
송신 측의 윈도우 크기는 맨 처음 TCP의 연결을 생성하는 과정인 3-Way Handshake 때 결정된다. 이때 송신 측과 수신 측은 자신의 현재 버퍼 크기를 서로에게 알려주게 되고, 송신 측은 수신 측이 보내준 버퍼 크기를 사용해 자신의 윈도우 크기를 정하게 된다.
### 1.2.2 송신 측이 윈도우 크기를 줄이는 이유
1. **네트워크 혼잡 관리**: 네트워크 상태가 불안정하거나 혼잡한 경우, 송신 측은 많은 데이터를 한꺼번에 보내지 않기 위해 윈도우 크기를 줄입니다. 이렇게 하면 네트워크가 과부하 상태에 빠지는 것을 예방할 수 있습니다.
    
2. **패킷 왕복 시간(RTT)**: 송신 측은 패킷이 목적지까지 도착하고 응답이 돌아오는 시간을 기반으로 전송 속도를 조절할 수 있습니다. 왕복 시간이 길다면, 네트워크 혼잡 가능성이 높으므로 **윈도우 크기를 줄여 전송 속도를 낮추는** 경우가 많습니다.
# 2. 오류 제어 (Erorr Control)
CP는 데이터가 손상되거나 유실되는 것을 허용하지 않는다. 네트워크 통신에서 오류가 발생하면, 이를 감지하고 다시 데이터를 전송하는 방식으로 오류를 처리한다. 이를 재전송 기반 오류제어, ARQ(Automatic Repeat Request)라고 부른다.
![[IMG-20241113182232704.png]]
- 패킷 기반 전송을 하는 TCP의 특성 상 각 패킷의 도착 순서가 무조건 보장되는 것이 아니기에, 중복된 ACK를 보통은 3회 정도 받았을 때 에러라고 판별한다.

즉, 데이터를 제대로 받지 못했으면 그 데이터를 다시 보내달라고 요청하는 방식이다. 이 방식이 TCP가 신뢰성을 제공하는 핵심 이유이다.

하지만 이 재전송이라는 작업 자체가 했던 일을 다시 해야하는 비효율적인 작업이기 때문에, 이 재전송 과정을 최대한 줄일 수 있는 여러 가지 방법을 사용하게 된다.

>⚠ **오류가 발생했다는 걸 확인하는 방법**
 TCP를 사용하는 송수신 측이 오류를 파악하는 방법은 크게 두 가지로 나누어진다.
> 
 수신 측이 송신 측에게 명시적으로 `NACK`(부정응답)을 보내는 방법, 그리고 송신 측에게 ACK(긍정응답)가 오지  않거나, 중복된 `ACK`가 계속해서 오면 오류가 발생했다고 추정하는 방법이다.
>
 간단히 생각해 보면 NACK을 사용하는 게 훨씬 명확하고 간단할 것 같지만, NACK을 사용하게 되면 수신 측이 상대방에게 ACK을 보낼지 NACK을 보낼지 선택해야 하는 로직이 추가적으로 필요하기 때문에, 일반적으로는 ACK만을 사용해 오류를 추정한다.
## 2.1 Stop and Wait
가장 기본적인 오류 제어 방식이다. 송신 측은 데이터를 하나 보낸 뒤, ACK를 기다린다. 만약 일정 시간 안에 ACK가 오지 않으면, 송신 측은 해당 데이터를 다시 보낸다.
![[IMG-20241113180245678.png]]
- 흐름 제어와 오류 제어가 동시에 가능
- 윈도우 안에 있는 데이터를 연속적으로 보내야 하기 때문에, 오류 제어에 Stop and Wait를 사용해 버리면 슬라이딩 윈도우를 사용하는 이점을 잃어버린다.
## 2.2. Go Back N
더 발전된 방식이 Go Back N ARQ이다. 송신 측은 여러 데이터를 연속적으로 보낼 수 있는데, 만약 중간에 하나의 패킷이 손실되면 그 이후에 보낸 모든 데이터를 다시 보내는 방식이다.
![[IMG-20241113183244146.png]]
- 이미 성공적으로 전송된 데이터까지 다시 보내기 때문에 조금 비효율적이긴 하다.
	- 하지만 Stop and Wait 보다는 많이 개선 되었다.
## 2.3 Selective Repeat
그래서 나온 방식이 Selective Repeat ARQ이다. Go Back N과 달리 손실된 데이터만 다시 보내는 방식이다.

e.g. 1, 2, 3, 4번 중 3번 데이터만 손실되었다면, 3번 데이터만 다시 보내면 된다.

하지만 이 방식은 수신 측에서 데이터를 정렬할 별도의 버퍼가 필요하고, 데이터가 순차적으로 오지 않을 수 있기 때문에 약간의 복잡성이 추가된다.
# 3. 혼잡 제어 (Congestion Control)
==혼잡 제어==는 <u>네트워크에서 혼잡 상태를 파악하고 이를 해결하기 위해 데이터 전송을 조절하는 기법이다.</u> 네트워크는 워낙 광대하고 블랙박스 같은 특성을 갖고 있어서, 어디에서 어떤 이유로 전송이 느려지는지 정확하게 파악하기 어렵다.
따라서 네트워크의 혼잡이 감지되면 최악의 상황을 피하기 위해 송신 측은 ==혼잡 윈도우(CWND)의== <u>크기를 줄여 데이터를 덜 보내는 방식으로 대응한다.</u> 이 과정이 바로 ==혼잡 제어==다.
## 3.1 혼잡 윈도우
혼잡 제어에서 중요한 개념인 혼잡 윈도우는 송신 측이 네트워크의 혼잡 상태를 고려해 정하는 윈도우 크기를 의미한다. 송신 측은 데이터를 보낼 때 수신 측에서 보내준 수신 윈도우(RWND)와 자신이 결정한 혼잡 윈도우 중 더 작은 값을 사용한다. 즉, 송신 윈도우 크기가 이 두 값에 의해 결정된다.
![[IMG-20241113183719394.png]]
혼잡 윈도우는 네트워크 상황을 반영해 계속 변화하는데, 여기서 조정하는 건 송신 윈도우가 아니라 송신 측의 혼잡 윈도우다.

## 3.2 혼잡 회피 방법
TCP 혼잡 제어 정책들은 혼잡 상태를 감지하는 방법과 혼잡 윈도우 크기를 조절하는 방식을 점차 발전시켜 왔다. 그 기본은 AIMD와 Slow Start라는 두 가지 기법을 상황에 맞게 조합해 사용하는 방식이다.
### 3.2.1 AIMD(Additive Increase/Multiplicative Decrease)
AIMD는 패킷을 처음 보낼 때 하나씩 보내고, 문제가 발생하지 않으면 전송 속도를 서서히 증가시키는 방식이다. 전송 속도는 1씩 추가적으로 늘어나고(Additive Increase), 만약 패킷 전송에 실패하면 전송 속도를 절반으로 줄인다.
![[IMG-20241113184220056.png]]
- 네트워크 자원을 공평하게 분배하는 데 효과적이다.
- AIMD의 문제점은 네트워크 대역이 펑펑 남아도는 상황에도 윈도우 크기를 너무 조금씩 늘리면서 접근한다는 것이다
### 3.2.2 Slow Start
Slow Start는 AIMD의 단점을 보완한 방식이다. AIMD는 전송 속도를 1씩 천천히 올리는 반면, Slow Start는 처음에 패킷을 하나 보내고, ACK를 받을 때마다 윈도우 크기를 지수적으로(2배씩) 늘려나간다. 혼잡이 감지되면 윈도우 크기를 1로 다시 줄이고, 그 후에는 혼잡이 발생할 때까지 빠르게 늘리다가 일정 부분에서부터는 천천히 1씩 증가시킨다.

이 방식 덕분에 네트워크 용량에 대한 정보를 빠르게 파악할 수 있고, 어느 정도 네트워크 수용량을 예측한 후 혼잡이 발생하기 전까지는 전송 속도를 계속해서 빠르게 늘릴 수 있다.

## 3.3 혼잡 제어 방법
TCP에서 혼잡 제어는 네트워크의 혼잡 상태를 감지하고 그에 맞춰 데이터 전송을 조절하는 방법이다. 주요 기법으로는 Tahoe와 Reno가 있으며, 이 두 가지 기법은 기본적으로 네트워크가 혼잡하다고 느껴졌을 때 윈도우 크기를 줄이거나, 증가를 멈추고 혼잡을 회피하는 방식으로 동작한다.

> **혼잡 감지 기준**
>- **Timeout**: 송신 측이 데이터를 보내고 나서 응답을 받지 못할 때 혼잡 상태라고 간주한다.
>- **3 `ACK` Duplicated**: 수신 측이 정상적으로 데이터를 받지 못해 같은 승인 번호(ACK)를 세 번 이상 보낼 경우, 송신 측은 네트워크에 문제가 있다고 판단한다.
>
 이 두 가지 상황이 발생하면 송신 측은 혼잡이 발생했다고 보고 윈도우 크기를 줄인다.

