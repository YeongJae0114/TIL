# 트랜잭션 전파 - 기본
>트랜잭션이 둘 이상 있을 때 트랜잭션은 어떻게 동작하는지 알아보고 트랜잭션 전파(propagation)라는 개념도 알아보자.

## 1. 단일 트랜잭션
![image](https://github.com/user-attachments/assets/771a417d-df7e-423d-9927-592092ca4909)
- 독립적인 2개의 트랜잭션이다.
- 이 2개의 트랜잭션은 서로 `commit`, `rollback에` 영향을 주지 않는다

**좀 더 자세히 트랜잭션의 동작을 살펴보면** 
![image](https://github.com/user-attachments/assets/b0cb861b-a0f5-4db5-a86c-6fd61492cfbf)
- 트랜잭션1 과 트랜잭션2는 각각의 다른 DB 커넥션을 가지고 있기 때문에 독립적으로 동작하는 것이다.
- 다른 DB 커넥션을 가지고 있기에 이 2개의 트랜잭션은 묶일 수 없다.

그럼 단일 트랜잭션의 경우 롤백은 어떻게 이뤄질까?

### 1.1 단일 트랜잭션의 rollback
![image](https://github.com/user-attachments/assets/1ec13125-20e9-4246-b94d-06590c33049a)
- 독립적인 2개의 트랜잭션 중 하나가 rollback을 수행해야한다.


**rollback 동작을 자세히 살펴보면**
![image](https://github.com/user-attachments/assets/1e9a26d2-eee8-41ca-b3bd-ac75fa7639d9)
- 트랜잭션1은 정상적으로 `commit` 을 완료한다.
  -  커넥션 풀에서 커넥션을 획득하고 `commit` 후에 커넥션 풀에 자원을 반납한다.
- 트랜잭션2은 정상적으로 `rollback` 을 수행한다.
  - 커넥션 풀에서 커넥션을 획득하고 `rollback` 이 발생했기 때문에 `commit` 을 수행하지 않고 
  - `rollback` 발생을 알리고 커넥션 풀에 자원을 반납한다.

>단일 트랜잭션의 경우 우리가 기대했던 방식으로 동작되기 때문에 쉽게 이해할 수 있다. 
하지만 트랜잭션 안에 트랜잭션이 수행되는 경우 트랜잭션이 어떻게 관리될까?? 또 외부 또는 내부의 트랜잭션에서 `rollback` 이 발생할 경우는 어떻게 트랜잭션이 동작할까?

## 2. 트랜잭션 전파
>트랜잭션을 각각 사용하는 것이 아니라, 트랜잭션이 이미 진행중인데, 여기에 추가로 트랜잭션을 수행하면 어떻게 될까? 
이런 경우 어떻게 동작할지 결정하는 것을 트랜잭션 전파(propagation)라 한다.
참고로 스프링은 다양한 트랜잭션 전파 옵션을 제공한다.
지금부터 설명하는 내용은 트랜잭션 전파의 기본 옵션인 `REQUIRED` 를 기준으로 설명한다.

**진행 중인 트랜잭션 안에서 트랜잭션이 수행될 때**
![image](https://github.com/user-attachments/assets/04d96c4d-a906-4cc9-9094-a6e81090a4d2)
- 외부 트랜잭션이 수행중이고, 아직 끝나지 않았는데, 내부 트랜잭션이 수행된다.
- 외부 트랜잭션이라고 이름 붙인 것은 둘 중 상대적으로 밖에 있기 때문에 외부 트랜잭션이라 한다.
  - 처음 시작된 트랜잭션으로 이해하면 된다.
- 내부 트랜잭션은 외부에 트랜잭션이 수행되고 있는 도중에 호출되기 때문에 마치 내부에 있는 것 처럼 보여서 내부 트랜잭션이라 한다.

### 2.1 스프링에서 트랜잭션 관리
![image](https://github.com/user-attachments/assets/326857d1-5044-4c8b-8264-085a5beb8c06)
- 외부 트랜잭션과 내부 트랜잭션을 묶어서 하나의 트랜잭션으로 관리한다.
- 내부 트랜잭션이 외부 트랜잭션에 참가하는 방식이다.(기본 방식)
- 여러기지 옵션을 사용해 다르게 동작 시킬 수 있다.

**논리 트랜잭션과 물리 트랜잭션이라는 개념 도입**
![image](https://github.com/user-attachments/assets/a3952fb2-7148-4bc8-b49b-33ba9cf1c49b)
- 논리 트랜잭션들은 하나의 물리 트랜잭션으로 묶인다.
- 물리 트랜잭션은 우리가 이해하는 실제 DB에 적용되는 트랜잭션을 말한다.
  - 실제 커넥션을 통해서 트랜잭션을 시작하고, `commit` , `rollback` 하는 단위이다.
- 논리 트랜잭션은 트랜잭션 매니저를 통해서 트랜잭션을 사용하는 단위이다.
- 결국 외부 트랜잭션과 내부 트랜잭션은 논리 트랜잭션으로 관리 한다는 뜻이다.
  - 이렇게 하면 내부에 사용되는 여러가지 복잡한 상황을 단순하게 관리할 수 있다.

### commit 성공 동작

![image](https://github.com/user-attachments/assets/525b5a6f-de29-4dd3-a63b-0b09e953ac04)

**요청 흐름 - 외부 트랜잭션**
1. `txManager.getTransaction()` 를 호출해서 외부 트랜잭션을 시작한다.
2. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성한다.
3. 생성한 커넥션을 수동 커밋 모드( `setAutoCommit(false)` )로 설정한다. - **물리 트랜잭션 시작**
4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다.
5. 트랜잭션 매니저는 트랜잭션을 생성한 결과를 `TransactionStatus` 에 담아서 반환하는데,
    - 여기에 신규 트랜잭션의 여부가 담겨 있다. `isNewTransaction` 를 통해 신규 트랜잭션 여부를 확인할 수 있다. 
    - 트랜잭션을 처음 시작했으므로 신규 트랜잭션이다.( `true` )
6. 로직1이 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을 획득해서 사용한다.

**요청 흐름 - 내부 트랜잭션**

7. `txManager.getTransaction()` 를 호출해서 내부 트랜잭션을 시작한다.
8. 트랜잭션 매니저는 트랜잭션 동기화 매니저를 통해서 기존 트랜잭션이 존재하는지 확인한다.
9. 기존 트랜잭션이 존재하므로 기존 트랜잭션에 참여한다. 기존 트랜잭션에 참여한다는 뜻은 사실 아무것도 하지 않는다는 뜻이다.
이미 기존 트랜잭션인 외부 트랜잭션에서 물리 트랜잭션을 시작했다. 그리고 물리 트랜잭션이 시작된 커넥 션을 트랜잭션 동기화 매니저에 담아두었다.
따라서 이미 물리 트랜잭션이 진행중이므로 그냥 두면 이후 로직이 기존에 시작된 트랜잭션을 자연스럽게 사용하게 되는 것이다.
이후 로직은 자연스럽게 트랜잭션 동기화 매니저에 보관된 기존 커넥션을 사용하게 된다.
10. 트랜잭션 매니저는 트랜잭션을 생성한 결과를 `TransactionStatus` 에 담아서 반환하는데, 여기에서 `isNewTransaction` 를 통해 신규 트랜잭션 여부를 확인할 수 있다. 여기서는 기존 트랜잭션에 참여했기 때문에 신규 트랜잭션이 아니다. ( `false` )
11. 로직2가 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 외부 트랜잭션이 보관한 커넥션을 획득해서 사용한다.

![image](https://github.com/user-attachments/assets/ed63ee3d-e48c-40c4-9374-7ff60ebdddc9)

12. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋한다.
13. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다.
    - 이 경우 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않는다. 
    - 이 부분이 중요한데, 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버린다. 
    - 아직 트랜잭션이 끝난 것이 아니기 때문에 실제 커밋을 호출하면 안된다. 
    - 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야한다.


### 외부 rollback 동작
![image](https://github.com/user-attachments/assets/85c8b1df-700e-40fb-8d23-e39307c937b7)

**응답 흐름 - 내부 트랜잭션**
1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋한다.
2. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 이 경우 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않는다.
    - 이 부분이 중요한데, 실제 커넥션에 커밋이나 롤백을 호출하면 물 리 트랜잭션이 끝나버린다.
    - 아직 트랜잭션이 끝난 것이 아니기 때문에 실제 커밋을 호출하면 안된다.
    - 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야한다.
  
**응답 흐름 - 외부 트랜잭션**

3. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 롤백한다.
4. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 외부 트랜잭션은 신규 트랜잭션이다. 따라서 DB 커넥션에 실제 롤백을 호출한다.
5. 트랜잭션 매니저에 롤백하는 것이 논리적인 롤백이라면, 실제 커넥션에 롤백하는 것을 물리 롤백이라 할 수 있다. 실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝난다.


### 내부 rollback 동작
![image](https://github.com/user-attachments/assets/9eca86a5-8c0e-49f0-b229-e65c3a3afcef)

**응답 흐름 - 내부 트랜잭션**
1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 롤백한다. (로직2에 문제가 있어서 롤백한다고 가정한다.)
2. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 이 경우 신규 트랜잭션이 아니기 때문에 실제 롤백을 호출하지 않는다.
    - 이 부분이 중요한데, 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버린다.
    - 아직 트랜잭션이 끝난 것이 아니기 때문에 실제 롤백을 호출하면 안된다.
    - 물리트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야한다.
3. 내부 트랜잭션은 물리 트랜잭션을 롤백하지 않는 대신에 트랜잭션 동기화 매니저에 `rollbackOnly=true` 라는 표시를 해둔다.

**응답 흐름 - 외부 트랜잭션**

4. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋한다.
5. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 외부 트랜잭션은 신규 트랜잭션이다. 
    - 따라서 DB 커넥션에 실제 커밋을 호출해야 한다. 이때 먼저 트랜잭션 동기화 매니저에 롤백 전용 ( `rollbackOnly=true` ) 표시가 있는지 확인한다.
    - 롤백 전용 표시가 있으면 물리 트랜잭션을 커밋하는 것이 아니라 롤백한다.
6. 실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝난다.
7. 트랜잭션 매니저에 커밋을 호출한 개발자 입장에서는 분명 커밋을 기대했는데 롤백 전용 표시로 인해 실제로는 롤백이 되어버렸다.
    - 이것은 조용히 넘어갈 수 있는 문제가 아니다. 
    - 시스템 입장에서는 커밋을 호출했지만 롤백이 되었다는 것은 분명하게 알려주어야 한다.
    - 예를 들어서 고객은 주문이 성공했다고 생각했는데, 실제로는 롤백이 되어서 주문이 생성되지 않은 것이다. 
    - 스프링은 이 경우 `UnexpectedRollbackException` 런타임 예외를 던진다.
    - 그래서 커밋을 시도했지 만, 기대하지 않은 롤백이 발생했다는 것을 명확하게 알려준다.
