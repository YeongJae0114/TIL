# 3-2.  트랜잭션 - 계좌이체

## 계좌이체 흐름

**sql 문에 오류가 없는 경우**

<img src="/img/Spring_DB/DB-3-11.png" alt="cookie2" width="800" height="300" />

1. 기본 데이터가 있다고 가정하고 계좌 정보에 접근한다.
2. 계좌이체를 위해서는 2개의 sql 문이 사용되고 이 2개의 sql은 하나로 동작해야한다.
3. 만약 문제가 생겼을 경우 롤백을 통해서 시스템의 문제가 해결되어야 한다.

**sql 문에 오류가 있을 경우**

<img src="/img/Spring_DB/DB_3-3.png" alt="cookie2" width="800" height="300" />

1. 기본 데이터가 있다고 가정하고 계좌 정보에 접근한다.
2. 계좌이체를 위해서는 2개의 sql 문이 사용되고 이 2개의 sql이 실행 될 때마다 자동으로 커밋이 호출 된다.
    1. 여기서 문제가 발생하는데 이때 sql문 중 하나가 오류가 발생한다면 한쪽 계좌에만 금액 변동만 있고 다른 쪽은 금액을 변동하지 않는다 . (계좌이체 로직 오류)
3. 문제가 생겼을 경우 롤백을 통해서 시스템의 문제가 해결 되지 않는다.

## DB 락 - 개념 이해

세션1이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데, 세션2에서 동시에 같은 데이터 를 수정하게 되면 여러가지 문제가 발생한다.

이런 문제를 방지하려면, 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에 서 해당 데이터를 수정할 수 없게 막아야 한다.

**커밋 시 락을 반환한다**

```sql
commit;
```

<img src="/img/Spring_DB/DB_3-4.png" alt="cookie2" width="600" height="150" />


1. 세션1은 memberA 의 money 를 500으로 변경을 시도
    1. 세션 1은 락을 획득
2. 세션1은 락을 획득했으므로 해당 로우에 update sql을 수행
3. 세션2도 `memberA` 의 `money` 데이터를 변경하려고 시도한다. 이때 해당 로우의 락을 먼저 획득해야 함
    1. 락이 없으므로 락이 돌아올 때 까지 대기
    2. 락 대기 시간을 넘어가면 락 타임아웃 오류가 발생
4. 세션1은 커밋을 수행한다. 커밋으로 트랜잭션이 종료되었으므로 락도 반납
5. 락을 획득하기 위해 대기하던 세션2가 락을 획득
6. 세션2는 update sql을 수행
7. 세션2는 커밋을 수행하고 트랜잭션이 종료되었으므로 락을 반납

> `SET LOCK_TIMEOUT <milliseconds>` : 락 타임아웃 시간을 설정한다.
예) `SET LOCK_TIMEOUT 10000` 10초, 세션2에 설정하면 세션2가 10초 동안 대기해도 락을 얻지 못하면 락 타임아웃 오류가 발생한다.
> 

## DB 락 - 조회

**일반적인 조회는 락을 사용하지 않는다**

조회 시점에 락이 필요한 경우에는 조회를 위한 락을 보유한다.

```sql
set autocommit false;
select * from member where member_id='memberA' for update;
```

- select for update 구문을 사용하면 조회를 하면서 동시에 선택한 로우의 락도 획득한다.
    - 물론 락이 없다면 락을 획득할 때 까지 대기해야 한다.
- 세션1은 트랜잭션을 종료할 때 까지 `memberA` 의 로우의 락을 보유한다.
