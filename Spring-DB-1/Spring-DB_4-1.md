## 트랜잭션 문제 해결 - 트랜잭션 매니저

### 트랜잭션 시작
<img src="/img/Spring_DB/DB-3_3.png" alt="Tx" width="800" height="300" />
1. 서비스 계층에서 TransactionManager.getTransaction()을 호출
2. 트랜잭션 시작을 위해 DB 커넥션을 받는다. (내부 데이터소스를 사용해 커넥션 생성)
3. 커넥션을 수동 커밋 모드로 변경해서 실제 데이터 베이스 트랜잭션을 시작
4. 커넥션을 트랜잭션 동기화 매니저에 보관
5. 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다. (멀티 쓰레드 환경에 안전하게 커넥션을 보관)  

<img src="/img/Spring_DB/DB-3_4.png" alt="Tx" width="800" height="300" />
6. 서비스는 비즈니스 로직을 실행하면서 리포지토리의 메서드들을 호출한다. (커넥션을 파라미터로 전달 X)
7. 리포지토리 메서드들은 트랜잭션이 시작된 커넥션이 필요하다. `DataSourceUtils.getConnection()` 을 사용해 동기화 매니저에 보관된 커넥션을 꺼내서 사용(같은 커넥션을 사용, 트랜잭션 유지)
8. 획득한 커넥션을 사용해 SQL을 데이터베이스에 전달해서 실행

<img src="/img/Spring_DB/DB-3_5.png" alt="Tx" width="800" height="300" />
9. 비즈니스 로직이 끝나면 트랜잭션을 종료. (커밋, 롤백 하면 종료)
10. 트랜잭션을 종료하려면 동기화된 커낵션이 필요하다. 동기화 매니저를 통해 커넥션 획득
11. 획득한 커넥션을 이용해 데이터베이스에 트랜잭션을 커밋, 롤백
12. 전체 리소스를 정리
	- 트랜잭션 동기화 매니저를 정리한다. 쓰레드 로컬은 사용후 꼭 정리	- `con.setAutoCommit(true)` 로 되돌린다. 커넥션 풀을 고려
	- `con.close()` 를 호출해셔 커넥션을 종료한다. 커넥션 풀을 사용하는 경우 `con.close()` 를 호출하면 커넥션 풀에 반환



**정리**
- 트랜잭션 추상화 덕분에 서비스 코드는 이제 JDBC 기술에 의존하지 않는다.
	- 이후 JDBC에서 JPA로 변경해도 서비스 코드를 그대로 유지할 수 있다.
	- 기술 변경시 의존관계 주입만 `DataSourceTransactionManager` 에서`JpaTransactionManager` 로 변경해주면 된다.
	- `java.sql.SQLException` 이 아직 남아있지만 이 부분은 뒤에 예외 문제에서 해결하자. 
- 트랜잭션 동기화 매니저 덕분에 커넥션을 파라미터로 넘기지 않아도 된다.

