# 9. 스프링 AOP 개념
## AOP 적용 방식
AOP를 사용하면 핵심 기능과 부가 기능이 완전 분리되어 관리된다.
그렇다면 AOP를 사용할 때 부가 기능 로직은 어떤 방식으로 실제 로직에 추가될 수 있을까?

**3가지 방법**
- 컴파일 시점 : `AspectJ 컴파일러 사용한 직접적인 방식`
- 클래스 로딩 시점 : `클래스 로더 조작기를 사용한 직접적인 방식`
- 런타임 시점 : `프록시 사용`


### 1. 컴파일 시점
**컴파일 타임 - 위빙**

`자바 코드가 컴파일 되는 시점에 AspectJ 컴파일러를 사용해 직접적으로 부가 기능을 적용하는 방식`
![image](https://github.com/user-attachments/assets/bc12487b-547c-497f-9ecc-3f399fcf558c)

- `.java` 소스 코드를 컴파일러를 사용해 `.class` 를 만드는 시점에 부가 기능 로직을 추가할 수 있다.
- AspectJ가 제공하는 특별한 컴파일러를 사용
  - AspectJ 컴파일러는 Aspect를 확인해서 해당 클래스가 적용 대상인지 먼저 확인
 
**단점**
- 컴파일 시점에 부가 기능을 적용하려면 특별한 컴파일러도 필요하고 복잡

### 2. 클래스 로딩 시점
`.class 를 JVM에 저장하기 전에 바이트 코드를 조작해 JVM에 저장`

![image](https://github.com/user-attachments/assets/49fde65a-034d-42d2-8709-502de20978d4)

- 수 많은 모니터링 툴들이 이 방식을 사용
- 자바를 실행하면 자바 언어는 `.class` 파일을 JVM 내부의 클래스 로더에 보관
  - 이 때 중간에서 `.class` 파일을 조작한 다음 JVM에 올린다.
- 이 시점에 애스 펙트를 적용하는 것을 로드 타임 위빙이라 함.

**클래스 로딩 시점 - 단점**
로드 타임 위빙은 자바를 실행할 때 특별한 옵션( `java -javaagent` )을 통해 클래스 로더 조작기를 지정해야 하는 데, 이 부분이 번거롭고 운영하기 어렵다.


### 3. 런타임 시점
`런타임 시점은 컴파일도 다 끝나고, 클래스 로더에 클래스도 다 올라가서 이미 자바가 실행되고 난 다음`

![image](https://github.com/user-attachments/assets/3f888130-83a3-403f-adcd-e94f2da742bb)
- 자바의 메인( `main` ) 메서드가 이미 실행된 다음
  - 자바 언어가 제공하는 범위 안에서 부가 기능을 적용
  - 프록시를 통해 스프링 빈에 부가 기능을 적용해야 한다.

### 부가 기능이 적용되는 차이점
`모두 핵심 기능과 부가 기능을 분리해 관리 된다 하지만 다음과 같은 차이가 있다. `
- **컴파일 시점:** 실제 대상 코드에 애스팩트를 통한 부가 기능 호출 코드가 포함된다. AspectJ를 직접 사용해야 한다.
- **클래스 로딩 시점:** 실제 대상 코드에 애스팩트를 통한 부가 기능 호출 코드가 포함된다. AspectJ를 직접 사용해야 한다.
- **런타임 시점:** 실제 대상 코드는 그대로 유지된다. 대신에 프록시를 통해 부가 기능이 적용된다. 따라서 항상 프록 시를 통해야 부가 기능을 사용할 수 있다. 스프링 AOP는 이 방식을 사용한다.


### AOP 적용 위치
`AOP는 지금까지 학습한 메서드 실행 위치 뿐만 아니라 다음과 같은 다양한 위치에 적용이 가능`
- 적용 가능 지점(조인 포인트): 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행
  - 이렇게 AOP를 적용할 수 있는 지점을 조인 포인트(Join point)
- AspectJ를 사용해서 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP는 바이트코드를 실제 조작
- 프록시 방식을 사용하는 스프링 AOP는 메서드 실행 지점에만 AOP를 적용
  - 프록시는 메서드 오버라이딩 개념으로 동작한다. 따라서 생성자나 static 메서드, 필드 값 접근에는 프록시 개념이 적용될 수 없다.
  - **스프링 AOP의 조인 포인트는 메서드 실행으로 제한**
- 프록시 방식을 사용하는 스프링 AOP는 스프링 컨테이너가 관리할 수 있는 **스프링 빈에만 AOP를 적용**


### 용어 정리
![image](https://github.com/user-attachments/assets/4f4fc14c-fe5b-4243-b5ba-a9d4569c620e)

- **조인 포인트(Join point)**
  - 어드바이스가 적용될 수 있는 위치, 메소드 실행, 생성자 호출, 필드 값 접근, static 메서드 접근 같은 프로 그램 실행 중 지점
  - 조인 포인트는 추상적인 개념이다. AOP를 적용할 수 있는 모든 지점이라 생각하면 된다.
  - AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메소드 실행 지점으로 제한된다.
- **포인트컷(Pointcut)**
  - 조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능
  - 주로 AspectJ 표현식을 사용해서 지정
  - 프록시를 사용하는 스프링 AOP는 메서드 실행 지점만 포인트컷으로 선별 가능
- **타켓(Target)**
  - 어드바이스를 받는 객체, 포인트컷으로 결정
- **어드바이스(Advice)** 부가 기능
  - 특정 조인 포인트에서 Aspect에 의해 취해지는 조치
  - Around(주변), Before(전), After(후)와 같은 다양한 종류의 어드바이스가 있음
- **애스펙트(Aspect)**
  - 어드바이스 + 포인트컷을 모듈화 한 것
  - `@Aspect` 를 생각하면 됨
  - 여러 어드바이스와 포인트 컷이 함께 존재
- **어드바이저(Advisor)** 
  - 하나의 어드바이스와 하나의 포인트 컷으로 구성 스프링 AOP에서만 사용되는 특별한 용어
- **위빙(Weaving)**
  - 포인트컷으로 결정한 타켓의 조인 포인트에 어드바이스를 적용하는 것 위빙을 통해 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가 할 수 있음
  - AOP 적용을 위해 애스펙트를 객체에 연결한 상태
    - 컴파일 타임(AspectJ compiler)
    - 로드 타임
    - 런타임, 스프링 AOP는 런타임, 프록시 방식
- **AOP 프록시**
  - AOP 기능을 구현하기 위해 만든 프록시 객체, 스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시이다.


